// Copyright 2016 Google, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go.
// source: doorman.proto
// DO NOT EDIT!

/*
Package doorman is a generated protocol buffer package.

It is generated from these files:
	doorman.proto

It has these top-level messages:
	Lease
	ResourceRequest
	GetCapacityRequest
	ResourceResponse
	Mastership
	GetCapacityResponse
	PriorityBandAggregate
	ServerCapacityResourceRequest
	GetServerCapacityRequest
	ServerCapacityResourceResponse
	GetServerCapacityResponse
	ReleaseCapacityRequest
	ReleaseCapacityResponse
	NamedParameter
	Algorithm
	ResourceTemplate
	ResourceRepository
	DiscoveryRequest
	DiscoveryResponse
*/
package doorman

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type Algorithm_Kind int32

const (
	Algorithm_NO_ALGORITHM       Algorithm_Kind = 0
	Algorithm_STATIC             Algorithm_Kind = 1
	Algorithm_PROPORTIONAL_SHARE Algorithm_Kind = 2
	Algorithm_FAIR_SHARE         Algorithm_Kind = 3
)

var Algorithm_Kind_name = map[int32]string{
	0: "NO_ALGORITHM",
	1: "STATIC",
	2: "PROPORTIONAL_SHARE",
	3: "FAIR_SHARE",
}
var Algorithm_Kind_value = map[string]int32{
	"NO_ALGORITHM":       0,
	"STATIC":             1,
	"PROPORTIONAL_SHARE": 2,
	"FAIR_SHARE":         3,
}

func (x Algorithm_Kind) Enum() *Algorithm_Kind {
	p := new(Algorithm_Kind)
	*p = x
	return p
}
func (x Algorithm_Kind) String() string {
	return proto.EnumName(Algorithm_Kind_name, int32(x))
}
func (x *Algorithm_Kind) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Algorithm_Kind_value, data, "Algorithm_Kind")
	if err != nil {
		return err
	}
	*x = Algorithm_Kind(value)
	return nil
}
func (Algorithm_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 0} }

// Encapsulates a lease on capacity with a expiry_time in seconds
// since the epoch.
type Lease struct {
	ExpiryTime       *int64   `protobuf:"varint,1,req,name=expiry_time" json:"expiry_time,omitempty"`
	RefreshInterval  *int64   `protobuf:"varint,2,req,name=refresh_interval" json:"refresh_interval,omitempty"`
	Capacity         *float64 `protobuf:"fixed64,3,req,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Lease) Reset()                    { *m = Lease{} }
func (m *Lease) String() string            { return proto.CompactTextString(m) }
func (*Lease) ProtoMessage()               {}
func (*Lease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Lease) GetExpiryTime() int64 {
	if m != nil && m.ExpiryTime != nil {
		return *m.ExpiryTime
	}
	return 0
}

func (m *Lease) GetRefreshInterval() int64 {
	if m != nil && m.RefreshInterval != nil {
		return *m.RefreshInterval
	}
	return 0
}

func (m *Lease) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

// Encapsulates the information we need to send to get capacity for a
// single resource.
type ResourceRequest struct {
	ResourceId       *string  `protobuf:"bytes,1,req,name=resource_id" json:"resource_id,omitempty"`
	Priority         *int64   `protobuf:"varint,2,req,name=priority" json:"priority,omitempty"`
	Has              *Lease   `protobuf:"bytes,3,opt,name=has" json:"has,omitempty"`
	Wants            *float64 `protobuf:"fixed64,4,req,name=wants" json:"wants,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ResourceRequest) Reset()                    { *m = ResourceRequest{} }
func (m *ResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*ResourceRequest) ProtoMessage()               {}
func (*ResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ResourceRequest) GetResourceId() string {
	if m != nil && m.ResourceId != nil {
		return *m.ResourceId
	}
	return ""
}

func (m *ResourceRequest) GetPriority() int64 {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return 0
}

func (m *ResourceRequest) GetHas() *Lease {
	if m != nil {
		return m.Has
	}
	return nil
}

func (m *ResourceRequest) GetWants() float64 {
	if m != nil && m.Wants != nil {
		return *m.Wants
	}
	return 0
}

// The GetCapacityRequest contains the identifier of the client making
// the request and a list of single resource capacity request protocol
// buffers.
type GetCapacityRequest struct {
	ClientId         *string            `protobuf:"bytes,1,req,name=client_id" json:"client_id,omitempty"`
	Resource         []*ResourceRequest `protobuf:"bytes,2,rep,name=resource" json:"resource,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *GetCapacityRequest) Reset()                    { *m = GetCapacityRequest{} }
func (m *GetCapacityRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCapacityRequest) ProtoMessage()               {}
func (*GetCapacityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetCapacityRequest) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *GetCapacityRequest) GetResource() []*ResourceRequest {
	if m != nil {
		return m.Resource
	}
	return nil
}

// Contains the capacity allocated by the server for a single
// resource.
type ResourceResponse struct {
	ResourceId       *string  `protobuf:"bytes,1,req,name=resource_id" json:"resource_id,omitempty"`
	Gets             *Lease   `protobuf:"bytes,2,req,name=gets" json:"gets,omitempty"`
	SafeCapacity     *float64 `protobuf:"fixed64,3,opt,name=safe_capacity" json:"safe_capacity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ResourceResponse) Reset()                    { *m = ResourceResponse{} }
func (m *ResourceResponse) String() string            { return proto.CompactTextString(m) }
func (*ResourceResponse) ProtoMessage()               {}
func (*ResourceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ResourceResponse) GetResourceId() string {
	if m != nil && m.ResourceId != nil {
		return *m.ResourceId
	}
	return ""
}

func (m *ResourceResponse) GetGets() *Lease {
	if m != nil {
		return m.Gets
	}
	return nil
}

func (m *ResourceResponse) GetSafeCapacity() float64 {
	if m != nil && m.SafeCapacity != nil {
		return *m.SafeCapacity
	}
	return 0
}

// This message type is used when the server wants to convey the
// address of a master. If the the optional master_address field
// is not there that means that the server wants to tell us who
// the master is, but it doesn't know.
type Mastership struct {
	MasterAddress    *string `protobuf:"bytes,1,opt,name=master_address" json:"master_address,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Mastership) Reset()                    { *m = Mastership{} }
func (m *Mastership) String() string            { return proto.CompactTextString(m) }
func (*Mastership) ProtoMessage()               {}
func (*Mastership) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Mastership) GetMasterAddress() string {
	if m != nil && m.MasterAddress != nil {
		return *m.MasterAddress
	}
	return ""
}

// The response to a GetCapacity request is a list of protocol buffers
// specifying the capacity for a single resource.
// If the mastership field is there the server is telling us that it is
// not the master. The new master is in the mastership message, unless
// the server does not know who the master is, in which case the
// mastership field will be there, but the master_address field in it will
// be empty.
type GetCapacityResponse struct {
	Response         []*ResourceResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	Mastership       *Mastership         `protobuf:"bytes,2,opt,name=mastership" json:"mastership,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *GetCapacityResponse) Reset()                    { *m = GetCapacityResponse{} }
func (m *GetCapacityResponse) String() string            { return proto.CompactTextString(m) }
func (*GetCapacityResponse) ProtoMessage()               {}
func (*GetCapacityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetCapacityResponse) GetResponse() []*ResourceResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *GetCapacityResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

type PriorityBandAggregate struct {
	Priority         *int64   `protobuf:"varint,1,req,name=priority" json:"priority,omitempty"`
	NumClients       *int64   `protobuf:"varint,2,req,name=num_clients" json:"num_clients,omitempty"`
	Wants            *float64 `protobuf:"fixed64,3,req,name=wants" json:"wants,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *PriorityBandAggregate) Reset()                    { *m = PriorityBandAggregate{} }
func (m *PriorityBandAggregate) String() string            { return proto.CompactTextString(m) }
func (*PriorityBandAggregate) ProtoMessage()               {}
func (*PriorityBandAggregate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PriorityBandAggregate) GetPriority() int64 {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return 0
}

func (m *PriorityBandAggregate) GetNumClients() int64 {
	if m != nil && m.NumClients != nil {
		return *m.NumClients
	}
	return 0
}

func (m *PriorityBandAggregate) GetWants() float64 {
	if m != nil && m.Wants != nil {
		return *m.Wants
	}
	return 0
}

type ServerCapacityResourceRequest struct {
	ResourceId       *string                  `protobuf:"bytes,1,req,name=resource_id" json:"resource_id,omitempty"`
	Has              *Lease                   `protobuf:"bytes,2,opt,name=has" json:"has,omitempty"`
	Wants            []*PriorityBandAggregate `protobuf:"bytes,3,rep,name=wants" json:"wants,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *ServerCapacityResourceRequest) Reset()                    { *m = ServerCapacityResourceRequest{} }
func (m *ServerCapacityResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*ServerCapacityResourceRequest) ProtoMessage()               {}
func (*ServerCapacityResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ServerCapacityResourceRequest) GetResourceId() string {
	if m != nil && m.ResourceId != nil {
		return *m.ResourceId
	}
	return ""
}

func (m *ServerCapacityResourceRequest) GetHas() *Lease {
	if m != nil {
		return m.Has
	}
	return nil
}

func (m *ServerCapacityResourceRequest) GetWants() []*PriorityBandAggregate {
	if m != nil {
		return m.Wants
	}
	return nil
}

type GetServerCapacityRequest struct {
	ServerId         *string                          `protobuf:"bytes,1,req,name=server_id" json:"server_id,omitempty"`
	Resource         []*ServerCapacityResourceRequest `protobuf:"bytes,2,rep,name=resource" json:"resource,omitempty"`
	XXX_unrecognized []byte                           `json:"-"`
}

func (m *GetServerCapacityRequest) Reset()                    { *m = GetServerCapacityRequest{} }
func (m *GetServerCapacityRequest) String() string            { return proto.CompactTextString(m) }
func (*GetServerCapacityRequest) ProtoMessage()               {}
func (*GetServerCapacityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetServerCapacityRequest) GetServerId() string {
	if m != nil && m.ServerId != nil {
		return *m.ServerId
	}
	return ""
}

func (m *GetServerCapacityRequest) GetResource() []*ServerCapacityResourceRequest {
	if m != nil {
		return m.Resource
	}
	return nil
}

type ServerCapacityResourceResponse struct {
	ResourceId       *string    `protobuf:"bytes,1,req,name=resource_id" json:"resource_id,omitempty"`
	Gets             *Lease     `protobuf:"bytes,2,req,name=gets" json:"gets,omitempty"`
	Algorithm        *Algorithm `protobuf:"bytes,3,opt,name=algorithm" json:"algorithm,omitempty"`
	SafeCapacity     *float64   `protobuf:"fixed64,4,opt,name=safe_capacity" json:"safe_capacity,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *ServerCapacityResourceResponse) Reset()                    { *m = ServerCapacityResourceResponse{} }
func (m *ServerCapacityResourceResponse) String() string            { return proto.CompactTextString(m) }
func (*ServerCapacityResourceResponse) ProtoMessage()               {}
func (*ServerCapacityResourceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ServerCapacityResourceResponse) GetResourceId() string {
	if m != nil && m.ResourceId != nil {
		return *m.ResourceId
	}
	return ""
}

func (m *ServerCapacityResourceResponse) GetGets() *Lease {
	if m != nil {
		return m.Gets
	}
	return nil
}

func (m *ServerCapacityResourceResponse) GetAlgorithm() *Algorithm {
	if m != nil {
		return m.Algorithm
	}
	return nil
}

func (m *ServerCapacityResourceResponse) GetSafeCapacity() float64 {
	if m != nil && m.SafeCapacity != nil {
		return *m.SafeCapacity
	}
	return 0
}

// The response to a GetServerCapacity request is a list of protocol buffers
// specifying the capacity for a single resource.
// If the mastership field is there the server is telling us that it is
// not the master. The new master is in the mastership message, unless
// the server does not know who the master is, in which case the
// mastership field will be there, but the master_address field in it will
// be empty.
type GetServerCapacityResponse struct {
	Response         []*ServerCapacityResourceResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
	Mastership       *Mastership                       `protobuf:"bytes,2,opt,name=mastership" json:"mastership,omitempty"`
	XXX_unrecognized []byte                            `json:"-"`
}

func (m *GetServerCapacityResponse) Reset()                    { *m = GetServerCapacityResponse{} }
func (m *GetServerCapacityResponse) String() string            { return proto.CompactTextString(m) }
func (*GetServerCapacityResponse) ProtoMessage()               {}
func (*GetServerCapacityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetServerCapacityResponse) GetResponse() []*ServerCapacityResourceResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *GetServerCapacityResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

// The ReleaseCapacity RPC instructs the server to release all leases
// that this client has on one or more resources. The lease is expected
// to expire as part of this RPC, so the client should not use the resource
// anymore.
type ReleaseCapacityRequest struct {
	ClientId         *string  `protobuf:"bytes,1,req,name=client_id" json:"client_id,omitempty"`
	ResourceId       []string `protobuf:"bytes,2,rep,name=resource_id" json:"resource_id,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ReleaseCapacityRequest) Reset()                    { *m = ReleaseCapacityRequest{} }
func (m *ReleaseCapacityRequest) String() string            { return proto.CompactTextString(m) }
func (*ReleaseCapacityRequest) ProtoMessage()               {}
func (*ReleaseCapacityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ReleaseCapacityRequest) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *ReleaseCapacityRequest) GetResourceId() []string {
	if m != nil {
		return m.ResourceId
	}
	return nil
}

// A ReleaseCapacity RPC can only fail if the server we are talking to
// is not the master. In that case the mastership field indicates who
// the master is (if we know, if we don't know the mastership field will
// be there but the optional master_addres field inside mastership will
// not be there).
type ReleaseCapacityResponse struct {
	Mastership       *Mastership `protobuf:"bytes,1,opt,name=mastership" json:"mastership,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *ReleaseCapacityResponse) Reset()                    { *m = ReleaseCapacityResponse{} }
func (m *ReleaseCapacityResponse) String() string            { return proto.CompactTextString(m) }
func (*ReleaseCapacityResponse) ProtoMessage()               {}
func (*ReleaseCapacityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ReleaseCapacityResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

// NamedParameter encapsulates a name/value pair which is used to
// configure an Algorithm (see below).
type NamedParameter struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NamedParameter) Reset()                    { *m = NamedParameter{} }
func (m *NamedParameter) String() string            { return proto.CompactTextString(m) }
func (*NamedParameter) ProtoMessage()               {}
func (*NamedParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *NamedParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NamedParameter) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Algorithm struct {
	// 应该使用Doorman的哪种算法来在客户端之间分配容量。
	Kind *Algorithm_Kind `protobuf:"varint,1,req,name=kind,enum=doorman.Algorithm_Kind" json:"kind,omitempty"`
	// How long should the lease be, in seconds.
	// 该算法所授予的容量租约的长度(单位为秒)。典型值为300秒。
	LeaseLength *int64 `protobuf:"varint,2,req,name=lease_length" json:"lease_length,omitempty"`
	// How many seconds should the client wait until refreshing its
	// lease.
	// 客户端请求联系Doorman服务器进行容量刷新的时间间隔(秒)。典型值为5秒。
	RefreshInterval *int64 `protobuf:"varint,3,req,name=refresh_interval" json:"refresh_interval,omitempty"`
	// 算法的命名参数是为算法指定附加参数的一种方法。
	Parameters []*NamedParameter `protobuf:"bytes,4,rep,name=parameters" json:"parameters,omitempty"`
	// By default the learning mode duration is the lease length,
	// however if you want to live dangerously, and assume that
	// clients are living up to their responsibility to contact
	// the server every refresh_interval, you can specify a shorter
	// learning mode here. You can also specify a longer learning
	// mode duration (longer than the lease length), but then you
	// are a muppet (or you do not trust the clients, in which case
	// you need to fix the client implementation).
	// Doorman服务器为该资源学习模式的持续时间。
	// 默认情况下，学习模式持续时间是租约长度，但是，如果您希望危险地生存，并假设客户端履行其责任，
	// 每次refresh_interval联系服务器，您可以在这里指定一个更短的学习模式。
	// 您还可以指定一个更长的学习模式持续时间(比租约长度更长)，
	//但是这样您就是一个傀儡(或者您不信任客户端，在这种情况下您需要修复客户端实现)。
	LearningModeDuration *int64 `protobuf:"varint,5,opt,name=learning_mode_duration" json:"learning_mode_duration,omitempty"`
	XXX_unrecognized     []byte `json:"-"`
}

func (m *Algorithm) Reset()                    { *m = Algorithm{} }
func (m *Algorithm) String() string            { return proto.CompactTextString(m) }
func (*Algorithm) ProtoMessage()               {}
func (*Algorithm) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Algorithm) GetKind() Algorithm_Kind {
	if m != nil && m.Kind != nil {
		return *m.Kind
	}
	return Algorithm_NO_ALGORITHM
}

func (m *Algorithm) GetLeaseLength() int64 {
	if m != nil && m.LeaseLength != nil {
		return *m.LeaseLength
	}
	return 0
}

func (m *Algorithm) GetRefreshInterval() int64 {
	if m != nil && m.RefreshInterval != nil {
		return *m.RefreshInterval
	}
	return 0
}

func (m *Algorithm) GetParameters() []*NamedParameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *Algorithm) GetLearningModeDuration() int64 {
	if m != nil && m.LearningModeDuration != nil {
		return *m.LearningModeDuration
	}
	return 0
}

// ResourceTemplate is used to instantiate the actual configuration
// for a resource based on a match with the identifier_glob glob.
type ResourceTemplate struct {
	// Glob used to match actual resources.
	// 用于确定哪个模板应用于哪个资源标识符。配置中的'*'捕获所有条目适用于无法找到更特定模板的所有资源。在搜索配置时，Doorman服务器首先尝试找到一个具有确切名称的资源模板(不进行globbing)。如果该搜索没有生成模板，则使用globbing匹配完成第二次遍历。
	IdentifierGlob *string `protobuf:"bytes,1,req,name=identifier_glob" json:"identifier_glob,omitempty"`
	// Capacity in service units
	// 资源的最大全局容量。这是Doorman能给的最大值。Doorman不知道单位是什么，但通常这个数字可以被认为是资源可以接受的最大qps(费率)或它可以处理的最大正在进行的事务(计量器)。
	Capacity *float64 `protobuf:"fixed64,2,req,name=capacity" json:"capacity,omitempty"`
	// Algorithm used to divide capacity between clients.
	Algorithm *Algorithm `protobuf:"bytes,3,req,name=algorithm" json:"algorithm,omitempty"`
	// Capacity to use in "safe" mode.
	// You can set this to a number and then the client will use that number
	// as the capacity in case it cannot refresh its lease.
	// If this field is absent the system returns a dynamic safe capacity in
	// the response, which is the available capacity divided by the number of
	// clients that the server knows about.
	// 资源的“安全容量”是Doorman客户端在Doorman服务器不可用时使用的容量。
	// 如果您将此设置为-1，Doorman限制将在Doorman下线时禁用。
	// 如果将其设置为0，则客户端将完全停止使用该资源。
	// 如果您将其设置为正数，那么每个客户端就会像从Doorman服务器接收到容量分配一样工作。
	// 如果不指定safe_capacity, Doorman服务器将计算动态安全容量，该容量等于配置的最大容量除以Doorman服务器知道的客户端数量。
	SafeCapacity *float64 `protobuf:"fixed64,4,opt,name=safe_capacity" json:"safe_capacity,omitempty"`
	// Description of the resource.
	Description      *string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ResourceTemplate) Reset()                    { *m = ResourceTemplate{} }
func (m *ResourceTemplate) String() string            { return proto.CompactTextString(m) }
func (*ResourceTemplate) ProtoMessage()               {}
func (*ResourceTemplate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ResourceTemplate) GetIdentifierGlob() string {
	if m != nil && m.IdentifierGlob != nil {
		return *m.IdentifierGlob
	}
	return ""
}

func (m *ResourceTemplate) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

func (m *ResourceTemplate) GetAlgorithm() *Algorithm {
	if m != nil {
		return m.Algorithm
	}
	return nil
}

func (m *ResourceTemplate) GetSafeCapacity() float64 {
	if m != nil && m.SafeCapacity != nil {
		return *m.SafeCapacity
	}
	return 0
}

func (m *ResourceTemplate) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

// The resource configuration consists of a list of templates.
type ResourceRepository struct {
	// List of ResourceTemplates specifying available resources. Order
	// of elements in this list is significant: it will be used to match
	// incoming requests. A template for * should be the last element.
	Resources        []*ResourceTemplate `protobuf:"bytes,1,rep,name=resources" json:"resources,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *ResourceRepository) Reset()                    { *m = ResourceRepository{} }
func (m *ResourceRepository) String() string            { return proto.CompactTextString(m) }
func (*ResourceRepository) ProtoMessage()               {}
func (*ResourceRepository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ResourceRepository) GetResources() []*ResourceTemplate {
	if m != nil {
		return m.Resources
	}
	return nil
}

// The request to obtain the master's address.
type DiscoveryRequest struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *DiscoveryRequest) Reset()                    { *m = DiscoveryRequest{} }
func (m *DiscoveryRequest) String() string            { return proto.CompactTextString(m) }
func (*DiscoveryRequest) ProtoMessage()               {}
func (*DiscoveryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

// The response containing the master's address.
type DiscoveryResponse struct {
	Mastership       *Mastership `protobuf:"bytes,1,req,name=mastership" json:"mastership,omitempty"`
	IsMaster         *bool       `protobuf:"varint,2,req,name=is_master" json:"is_master,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *DiscoveryResponse) Reset()                    { *m = DiscoveryResponse{} }
func (m *DiscoveryResponse) String() string            { return proto.CompactTextString(m) }
func (*DiscoveryResponse) ProtoMessage()               {}
func (*DiscoveryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DiscoveryResponse) GetMastership() *Mastership {
	if m != nil {
		return m.Mastership
	}
	return nil
}

func (m *DiscoveryResponse) GetIsMaster() bool {
	if m != nil && m.IsMaster != nil {
		return *m.IsMaster
	}
	return false
}

func init() {
	proto.RegisterType((*Lease)(nil), "doorman.Lease")
	proto.RegisterType((*ResourceRequest)(nil), "doorman.ResourceRequest")
	proto.RegisterType((*GetCapacityRequest)(nil), "doorman.GetCapacityRequest")
	proto.RegisterType((*ResourceResponse)(nil), "doorman.ResourceResponse")
	proto.RegisterType((*Mastership)(nil), "doorman.Mastership")
	proto.RegisterType((*GetCapacityResponse)(nil), "doorman.GetCapacityResponse")
	proto.RegisterType((*PriorityBandAggregate)(nil), "doorman.PriorityBandAggregate")
	proto.RegisterType((*ServerCapacityResourceRequest)(nil), "doorman.ServerCapacityResourceRequest")
	proto.RegisterType((*GetServerCapacityRequest)(nil), "doorman.GetServerCapacityRequest")
	proto.RegisterType((*ServerCapacityResourceResponse)(nil), "doorman.ServerCapacityResourceResponse")
	proto.RegisterType((*GetServerCapacityResponse)(nil), "doorman.GetServerCapacityResponse")
	proto.RegisterType((*ReleaseCapacityRequest)(nil), "doorman.ReleaseCapacityRequest")
	proto.RegisterType((*ReleaseCapacityResponse)(nil), "doorman.ReleaseCapacityResponse")
	proto.RegisterType((*NamedParameter)(nil), "doorman.NamedParameter")
	proto.RegisterType((*Algorithm)(nil), "doorman.Algorithm")
	proto.RegisterType((*ResourceTemplate)(nil), "doorman.ResourceTemplate")
	proto.RegisterType((*ResourceRepository)(nil), "doorman.ResourceRepository")
	proto.RegisterType((*DiscoveryRequest)(nil), "doorman.DiscoveryRequest")
	proto.RegisterType((*DiscoveryResponse)(nil), "doorman.DiscoveryResponse")
	proto.RegisterEnum("doorman.Algorithm_Kind", Algorithm_Kind_name, Algorithm_Kind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Capacity service

type CapacityClient interface {
	// Used by clients to discover the master Doorman server.
	Discovery(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error)
	// GetCapacity Used by clients to obtain capacity from Doorman.
	// 用于客户端从doorman处获得容量。
	GetCapacity(ctx context.Context, in *GetCapacityRequest, opts ...grpc.CallOption) (*GetCapacityResponse, error)
	// GetServerCapacity Used by Doorman servers to get capacity on behalf of their clients from
	// lower level Doorman servers.
	// 由Doorman服务器使用，代表其客户从较低级别的Doorman服务器获得容量。
	GetServerCapacity(ctx context.Context, in *GetServerCapacityRequest, opts ...grpc.CallOption) (*GetServerCapacityResponse, error)
	// Used by clients to release any capacity they have for one or more
	// resources.
	ReleaseCapacity(ctx context.Context, in *ReleaseCapacityRequest, opts ...grpc.CallOption) (*ReleaseCapacityResponse, error)
}

type capacityClient struct {
	cc *grpc.ClientConn
}

func NewCapacityClient(cc *grpc.ClientConn) CapacityClient {
	return &capacityClient{cc}
}

func (c *capacityClient) Discovery(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error) {
	out := new(DiscoveryResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/Discovery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *capacityClient) GetCapacity(ctx context.Context, in *GetCapacityRequest, opts ...grpc.CallOption) (*GetCapacityResponse, error) {
	out := new(GetCapacityResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/GetCapacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *capacityClient) GetServerCapacity(ctx context.Context, in *GetServerCapacityRequest, opts ...grpc.CallOption) (*GetServerCapacityResponse, error) {
	out := new(GetServerCapacityResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/GetServerCapacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *capacityClient) ReleaseCapacity(ctx context.Context, in *ReleaseCapacityRequest, opts ...grpc.CallOption) (*ReleaseCapacityResponse, error) {
	out := new(ReleaseCapacityResponse)
	err := grpc.Invoke(ctx, "/doorman.Capacity/ReleaseCapacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Capacity service

type CapacityServer interface {
	// Used by clients to discover the master Doorman server.
	Discovery(context.Context, *DiscoveryRequest) (*DiscoveryResponse, error)
	// Used by clients to obtain capacity from Doorman.
	GetCapacity(context.Context, *GetCapacityRequest) (*GetCapacityResponse, error)
	// Used by Doorman servers to get capacity on behalf of their clients from
	// lower level Doorman servers.
	GetServerCapacity(context.Context, *GetServerCapacityRequest) (*GetServerCapacityResponse, error)
	// Used by clients to release any capacity they have for one or more
	// resources.
	ReleaseCapacity(context.Context, *ReleaseCapacityRequest) (*ReleaseCapacityResponse, error)
}

func RegisterCapacityServer(s *grpc.Server, srv CapacityServer) {
	s.RegisterService(&_Capacity_serviceDesc, srv)
}

func _Capacity_Discovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CapacityServer).Discovery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Capacity_GetCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CapacityServer).GetCapacity(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Capacity_GetServerCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetServerCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CapacityServer).GetServerCapacity(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Capacity_ReleaseCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReleaseCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CapacityServer).ReleaseCapacity(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Capacity_serviceDesc = grpc.ServiceDesc{
	ServiceName: "doorman.Capacity",
	HandlerType: (*CapacityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Discovery",
			Handler:    _Capacity_Discovery_Handler,
		},
		{
			MethodName: "GetCapacity",
			Handler:    _Capacity_GetCapacity_Handler,
		},
		{
			MethodName: "GetServerCapacity",
			Handler:    _Capacity_GetServerCapacity_Handler,
		},
		{
			MethodName: "ReleaseCapacity",
			Handler:    _Capacity_ReleaseCapacity_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 962 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0x66, 0xc6, 0x0e, 0x78, 0xca, 0x89, 0xe3, 0xed, 0x5d, 0xb2, 0x5e, 0x2f, 0xec, 0x66, 0x07,
	0xc1, 0x2e, 0x42, 0x8a, 0x50, 0x58, 0x84, 0xc4, 0xcd, 0xc9, 0x42, 0x62, 0xe1, 0xc4, 0x51, 0xc7,
	0xe2, 0xc0, 0x65, 0x34, 0x78, 0x3a, 0xe3, 0x06, 0xcf, 0x0f, 0xdd, 0x63, 0x20, 0x82, 0x0b, 0x17,
	0xde, 0x00, 0x89, 0x87, 0xe1, 0xc6, 0x8d, 0x13, 0x8f, 0x44, 0xf5, 0x4c, 0xcf, 0x8f, 0xed, 0x71,
	0xd8, 0x48, 0x39, 0x25, 0xfd, 0x55, 0x4d, 0xd7, 0x57, 0x55, 0x5f, 0x75, 0x19, 0x76, 0xbc, 0x28,
	0x12, 0x81, 0x1b, 0x1e, 0xc4, 0x22, 0x4a, 0x22, 0xf2, 0x96, 0x3e, 0xda, 0x11, 0x6c, 0x8d, 0x98,
	0x2b, 0x19, 0x79, 0x0a, 0x6d, 0xf6, 0x73, 0xcc, 0xc5, 0xb5, 0x93, 0xf0, 0x80, 0xf5, 0x8c, 0x7d,
	0xf3, 0x45, 0x83, 0x42, 0x06, 0x4d, 0x10, 0x21, 0x1f, 0x42, 0x57, 0xb0, 0x2b, 0xc1, 0xe4, 0xcc,
	0xe1, 0x61, 0xc2, 0xc4, 0x8f, 0xee, 0xbc, 0x67, 0xa6, 0x5e, 0xbb, 0x1a, 0x1f, 0x6a, 0x98, 0xf4,
	0xa1, 0x35, 0x75, 0x63, 0x77, 0xca, 0x93, 0xeb, 0x5e, 0x03, 0x5d, 0x0c, 0x5a, 0x9c, 0xed, 0xdf,
	0x0d, 0xd8, 0xa5, 0x4c, 0x46, 0x0b, 0x31, 0x65, 0x94, 0xfd, 0xb0, 0x60, 0x32, 0x51, 0xb1, 0x85,
	0x86, 0x1c, 0xee, 0xa5, 0xb1, 0x2d, 0x0a, 0x39, 0x34, 0xf4, 0xd4, 0x85, 0xb1, 0xe0, 0x91, 0x50,
	0x17, 0x66, 0x31, 0x8b, 0x33, 0xd9, 0x87, 0xc6, 0xcc, 0x95, 0x18, 0xc7, 0x78, 0xd1, 0x3e, 0xec,
	0x1c, 0xe4, 0x79, 0xa6, 0x59, 0x51, 0x65, 0x22, 0x0f, 0x60, 0xeb, 0x27, 0x37, 0x4c, 0x64, 0xaf,
	0x99, 0x72, 0xc9, 0x0e, 0xb6, 0x0f, 0xe4, 0x84, 0x25, 0xc7, 0x9a, 0x57, 0x4e, 0xe5, 0x31, 0x58,
	0xd3, 0x39, 0x67, 0x61, 0x52, 0x12, 0x69, 0x65, 0x00, 0xd2, 0x78, 0x09, 0xad, 0x9c, 0x14, 0xd2,
	0x68, 0x60, 0xbc, 0x5e, 0x11, 0x6f, 0x25, 0x27, 0x5a, 0x78, 0xda, 0xbf, 0x42, 0xb7, 0x34, 0xca,
	0x38, 0x0a, 0xb3, 0x6a, 0xdf, 0x9c, 0xb1, 0x0d, 0x4d, 0x9f, 0x21, 0x65, 0x95, 0xed, 0x7a, 0x5a,
	0xa9, 0x8d, 0xbc, 0x07, 0x3b, 0xd2, 0xbd, 0x62, 0x4e, 0xa5, 0xd6, 0x06, 0xe6, 0xb7, 0xad, 0xc0,
	0x3c, 0x2f, 0xfb, 0x13, 0x80, 0x33, 0x57, 0x62, 0x63, 0xe4, 0x8c, 0xc7, 0xe4, 0x7d, 0xe8, 0x04,
	0xe9, 0xc9, 0x71, 0x3d, 0x0f, 0xc3, 0x49, 0x0c, 0x6d, 0x60, 0xe8, 0x9d, 0x0c, 0x1d, 0x64, 0xa0,
	0xfd, 0x9b, 0x01, 0xf7, 0x97, 0x8a, 0xa3, 0x69, 0x7f, 0x9a, 0x16, 0x20, 0xfd, 0x1f, 0x3f, 0x54,
	0x05, 0x78, 0x54, 0x53, 0x80, 0xcc, 0x81, 0x16, 0xae, 0x04, 0x39, 0x04, 0x05, 0x07, 0x4c, 0x49,
	0x75, 0xea, 0x7e, 0xf1, 0x61, 0x49, 0x8f, 0x56, 0xdc, 0xec, 0xef, 0xe0, 0xed, 0x0b, 0xdd, 0xe3,
	0x23, 0x37, 0xf4, 0x06, 0xbe, 0x2f, 0x98, 0xef, 0x26, 0x6c, 0x49, 0x0c, 0xc6, 0x8a, 0x18, 0xb0,
	0xae, 0xe1, 0x22, 0x70, 0xb2, 0x8e, 0x49, 0xad, 0x15, 0x40, 0xe8, 0x38, 0x43, 0x4a, 0x2d, 0x34,
	0xaa, 0x5a, 0xf8, 0xd3, 0x80, 0x77, 0x2f, 0x51, 0xbb, 0x4c, 0x54, 0x52, 0xbe, 0x9d, 0x44, 0xb5,
	0x0c, 0xcd, 0xcd, 0x32, 0x7c, 0x59, 0x86, 0x56, 0x95, 0x7b, 0x52, 0xf8, 0xd4, 0xa6, 0x99, 0x53,
	0xfb, 0x05, 0x7a, 0xd8, 0x89, 0x55, 0x72, 0x85, 0x58, 0x65, 0x6a, 0xa8, 0x88, 0x35, 0x03, 0x90,
	0xd0, 0xd1, 0x9a, 0x58, 0x3f, 0x28, 0x22, 0xde, 0x98, 0x6b, 0x45, 0xba, 0x7f, 0x19, 0xf0, 0x64,
	0x93, 0xef, 0x5d, 0x2a, 0xf9, 0x63, 0xb0, 0xdc, 0xb9, 0xaf, 0x8a, 0x30, 0x0b, 0xf4, 0x24, 0x93,
	0xc2, 0x71, 0x90, 0x5b, 0x68, 0xe9, 0xb4, 0xae, 0xfd, 0x66, 0x8d, 0xf6, 0xff, 0x30, 0xe0, 0x51,
	0x4d, 0xf1, 0x34, 0xf3, 0xe3, 0x35, 0x31, 0x3f, 0xff, 0xdf, 0x02, 0xdd, 0x8d, 0xb4, 0xbf, 0x86,
	0x3d, 0xca, 0xe6, 0x2a, 0xff, 0x5b, 0x3d, 0x3f, 0x2b, 0xa5, 0x56, 0x4d, 0x5d, 0x2a, 0xb5, 0x7d,
	0x0e, 0x0f, 0xd7, 0xee, 0xad, 0xe5, 0x69, 0xbc, 0x1e, 0xcf, 0xcf, 0xa1, 0x73, 0xee, 0x06, 0xcc,
	0xbb, 0x70, 0x05, 0xfe, 0x41, 0x94, 0x10, 0x68, 0x86, 0xae, 0x5e, 0x0f, 0x16, 0x4d, 0xff, 0x57,
	0x23, 0x85, 0x8f, 0xfe, 0x82, 0xa5, 0xd9, 0x5b, 0x34, 0x3b, 0xd8, 0x7f, 0x9b, 0x60, 0x15, 0x9d,
	0x23, 0x1f, 0x41, 0xf3, 0x7b, 0x1e, 0x66, 0x29, 0x75, 0x0e, 0x1f, 0xae, 0xf7, 0xf6, 0xe0, 0x2b,
	0x34, 0xd3, 0xd4, 0x89, 0x3c, 0x83, 0xed, 0x34, 0x09, 0x67, 0xce, 0x42, 0x3f, 0x99, 0xe9, 0x29,
	0x6e, 0xa7, 0xd8, 0x28, 0x85, 0x6a, 0x97, 0x51, 0xa3, 0x7e, 0x19, 0x7d, 0x06, 0x10, 0xe7, 0xfc,
	0xd5, 0x0a, 0x50, 0x8d, 0x2e, 0x09, 0x2c, 0xe7, 0x47, 0x2b, 0xae, 0x38, 0xaf, 0x7b, 0x18, 0x52,
	0x84, 0x3c, 0xf4, 0x9d, 0x20, 0xf2, 0x98, 0xe3, 0x2d, 0x84, 0x9b, 0xf0, 0x28, 0xec, 0x6d, 0x61,
	0xa2, 0x0d, 0xfa, 0x20, 0xb7, 0x9e, 0xa1, 0xf1, 0x95, 0xb6, 0xd9, 0x23, 0x68, 0xaa, 0x54, 0x48,
	0x17, 0xb6, 0xcf, 0xc7, 0xce, 0x60, 0x74, 0x32, 0xa6, 0xc3, 0xc9, 0xe9, 0x59, 0xf7, 0x0d, 0x02,
	0xf0, 0xe6, 0xe5, 0x64, 0x30, 0x19, 0x1e, 0x77, 0x0d, 0xb2, 0x07, 0xe4, 0x82, 0x8e, 0x2f, 0xc6,
	0x74, 0x32, 0x1c, 0x9f, 0x0f, 0x46, 0xce, 0xe5, 0xe9, 0x80, 0x7e, 0xd1, 0x35, 0x49, 0x07, 0xe0,
	0xcb, 0xc1, 0x90, 0xea, 0x73, 0xc3, 0xfe, 0xd7, 0x28, 0x97, 0xc7, 0x84, 0x05, 0xf1, 0x5c, 0x3d,
	0x80, 0xcf, 0x61, 0x97, 0x7b, 0x28, 0x09, 0x7e, 0xc5, 0x71, 0xf4, 0xfd, 0x79, 0xf4, 0xad, 0xee,
	0x47, 0xa7, 0x84, 0x4f, 0x10, 0x5d, 0xda, 0xc3, 0xe6, 0xf2, 0x1e, 0x5e, 0x1d, 0x39, 0xf3, 0x6e,
	0x46, 0x0e, 0x9f, 0xc1, 0xb6, 0xc7, 0xe4, 0x54, 0xf0, 0xb8, 0xa8, 0x94, 0x45, 0xab, 0x90, 0x7d,
	0x06, 0xa4, 0x9c, 0xa7, 0x38, 0x92, 0x3c, 0x89, 0xc4, 0x35, 0x76, 0xc9, 0xca, 0x85, 0x2c, 0x37,
	0xae, 0x96, 0xbc, 0x02, 0xb4, 0xf4, 0xb5, 0x09, 0x74, 0x5f, 0x71, 0x39, 0x8d, 0x70, 0x5c, 0xf3,
	0x29, 0xb2, 0x19, 0xdc, 0xab, 0x60, 0x1b, 0x26, 0xc0, 0x7c, 0x8d, 0x09, 0x50, 0xf3, 0xc8, 0xa5,
	0x93, 0x01, 0x69, 0x09, 0x5b, 0xb4, 0xc5, 0x65, 0xe6, 0x7c, 0xf8, 0x8f, 0x09, 0xad, 0x22, 0xf1,
	0x23, 0xb0, 0x8a, 0x98, 0xa4, 0xa4, 0xbe, 0xca, 0xad, 0xdf, 0xaf, 0x33, 0x69, 0x8a, 0xa7, 0xd0,
	0xae, 0x6c, 0x5d, 0xf2, 0xb8, 0x70, 0x5d, 0xff, 0xa1, 0xd2, 0x7f, 0xa7, 0xde, 0xa8, 0x6f, 0xfa,
	0x06, 0xee, 0xad, 0x3d, 0x7c, 0xe4, 0x59, 0xf5, 0x93, 0xda, 0x8d, 0xd2, 0xb7, 0x6f, 0x72, 0xd1,
	0x77, 0x4f, 0xd4, 0x0f, 0xb8, 0xa5, 0x57, 0x86, 0x3c, 0xad, 0xb4, 0xaa, 0xee, 0x5d, 0xeb, 0xef,
	0x6f, 0x76, 0xc8, 0x6e, 0xfd, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xb0, 0x80, 0x24, 0xe3, 0xa1, 0x0a,
	0x00, 0x00,
}
